<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SRT to GCML Converter (v35)</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 20px auto; padding: 10px; border: 1px solid #ccc; border-radius: 8px; }
    h1 { text-align: center; }
    input[type="file"] { display: block; margin-top: 10px; }
    #status { text-align: center; font-weight: bold; }
    label { font-weight: bold; }
    select { margin-left: 10px; padding: 5px; }
    .config-section { margin-top: 15px; }
    .config-section label { font-weight: normal; margin-left: 5px; }
    .config-title { font-weight: bold; margin-bottom: 5px; }
    .filter-list-upload { padding-bottom: 10px; border-bottom: 1px dashed #ccc; }
    .filter-list-upload .note { font-size: 0.9em; color: #555; margin-top: 5px; }
    .inline { display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .small { font-size: 0.9em; color: #555; }
    select, input[type="file"] { max-width: 100%; }
  </style>
</head>
<body>
  <h1>SRT → GCML 変換ツール (v35: Shift_JIS/CP932対策 + CDATA安全化)</h1>
  <p>1. 下のオプションを設定してください。</p>
  <p>2. <strong>.srt</strong> ファイルを選択すると、自動的に <strong>.gcml</strong> ファイルがダウンロードされます。</p>

  <hr>

  <div class="config-section">
    <div class="config-title">1. 字幕の色:</div>
    <select id="fontColorSelect">
      <option value="white" selected>白</option>
      <option value="cyan">水色</option>
      <option value="green">緑</option>
      <option value="yellow">黄色</option>
      <option value="LightOrange">オレンジ</option>
      <option value="PaleMagenta">ピンク</option>
    </select>
  </div>

  <div class="config-section">
    <div class="config-title">2. 文字コード:</div>
    <div class="inline">
      <label for="encodingSelect" style="font-weight:bold;">SRT読み込み:</label>
      <select id="encodingSelect">
        <option value="auto" selected>自動（UTF-8→Shift_JIS/CP932）</option>
        <option value="utf-8">UTF-8固定</option>
        <option value="shift_jis">Shift_JIS/CP932固定</option>
      </select>
    </div>
    <div class="small" style="margin-top:6px;">
      ※ ブラウザ標準の <code>TextDecoder</code> を使用します。古いブラウザでは「UTF-8固定」相当になる場合があります。
    </div>
  </div>

  <div class="config-section">
    <div class="config-title">3. 変換ルール:</div>

    <div class="filter-list-upload">
      <label for="filterFile">A. フィルターリスト (任意):</label>
      <input type="file" id="filterFile" accept=".csv,.txt" />
      <div class="note">※ <code>置換前,置換後</code> のCSV/TXTを先に読み込ませてください。</div>
    </div>

    <label style="margin-top: 10px; display: block;">B. チェックボックスルール:</label>

    <div>
      <input type="checkbox" id="chkMergeShortPages" checked />
      <label for="chkMergeShortPages">表示時間が短い (1秒20F以下) ページを結合する</label>
    </div>

    <div>
      <input type="checkbox" id="chkReplaceEnvChars" checked />
      <label for="chkReplaceEnvChars">環境依存文字 (①, ㈱, ㎜ など) を ＊ に置き換える</label>
    </div>

    <div>
      <input type="checkbox" id="chkRemovePunctuation" checked />
      <label for="chkRemovePunctuation">句読点 (、。．,) を削除する</label>
    </div>

    <div>
      <input type="checkbox" id="chkToFullWidth" checked />
      <label for="chkToFullWidth">半角英数字/記号 (!?) を全角にする</label>
    </div>

    <div>
      <input type="checkbox" id="chkHyphenToChoonpu" checked />
      <label for="chkHyphenToChoonpu">ハイフン (-) を長音符 (ー) にする</label>
    </div>
  </div>

  <div class="config-section">
    <div class="config-title">4. .srt ファイルの選択:</div>
    <input type="file" id="srtFile" accept=".srt" />
  </div>

  <p id="status"></p>

  <script>
    let filterRules = [];

    document.getElementById('filterFile').addEventListener('change', handleFilterFile, false);
    document.getElementById('srtFile').addEventListener('change', handleFileSelect, false);

    function normalizeNewlines(s) {
      return (s || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }

    // ---------- (1) Shift_JIS/CP932対策：TextDecoderで読む ----------
    async function readFileWithEncoding(file, encodingMode) {
      // encodingMode: "auto" | "utf-8" | "shift_jis"
      const buf = await file.arrayBuffer();

      // TextDecoderがない古い環境では、従来通りUTF-8扱いにフォールバック
      if (typeof TextDecoder === "undefined") {
        const fallback = await readAsTextFallback(file);
        return { text: fallback, usedEncoding: "utf-8(fallback)" };
      }

      const decode = (enc, fatal) => {
        // fatal=true なら不正バイトで例外
        return new TextDecoder(enc, { fatal: !!fatal }).decode(buf);
      };

      if (encodingMode === "utf-8") {
        return { text: decode("utf-8", false), usedEncoding: "utf-8" };
      }
      if (encodingMode === "shift_jis") {
        // ブラウザによっては "shift_jis" が未対応の場合があるので try/catch
        try {
          return { text: decode("shift_jis", false), usedEncoding: "shift_jis/cp932" };
        } catch (e) {
          // 未対応ならUTF-8で読むしかない
          return { text: decode("utf-8", false), usedEncoding: "utf-8(fallback)" };
        }
      }

      // auto: まずUTF-8を fatal=true で試す → 失敗したら shift_jis
      try {
        const t = decode("utf-8", true);
        return { text: t, usedEncoding: "utf-8(auto)" };
      } catch (e) {
        try {
          const t = decode("shift_jis", false);
          return { text: t, usedEncoding: "shift_jis/cp932(auto)" };
        } catch (e2) {
          // shift_jis未対応環境の最終手段
          const t = decode("utf-8", false);
          return { text: t, usedEncoding: "utf-8(fallback)" };
        }
      }
    }

    function readAsTextFallback(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(new Error("ファイル読み込みに失敗しました。"));
        r.onload = (e) => resolve((e.target && e.target.result) ? e.target.result : "");
        r.readAsText(file, "UTF-8");
      });
    }

    function handleFilterFile(evt) {
      const file = evt.target.files[0];
      if (!file) return;

      // フィルターはUTF-8想定（必要ならここもencodingSelectに追従させられる）
      const reader = new FileReader();
      reader.readAsText(file, 'UTF-8');

      reader.onload = function(e) {
        const text = normalizeNewlines(e.target.result);
        filterRules = [];

        const lines = text.split('\n');
        for (const line of lines) {
          if (line.trim() === "") continue;

          const parts = line.split(',');
          if (parts.length >= 2 && parts[0].trim() !== "") {
            const find = parts[0];
            const replace = parts.slice(1).join(','); // 置換後にカンマを含む場合も拾う
            filterRules.push({ find, replace });
          }
        }

        document.getElementById('status').innerText =
          `フィルターリスト ${filterRules.length} 件を読み込みました。SRTファイルを選択してください。`;
      };
    }

    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function toFullWidth(str) {
      if (!str) return "";
      return str.replace(/[0-9a-zA-Z!?]/g, function(s) {
        return String.fromCharCode(s.charCodeAt(0) + 0xFEE0);
      });
    }

    function parseTimeToMs(h, m, s, ms) {
      return (parseInt(h, 10) * 3600 + parseInt(m, 10) * 60 + parseInt(s, 10)) * 1000 + parseInt(ms, 10);
    }

    // サロゲートペア等を割らない “文字単位” の分割
    function splitByChars(str, maxChars) {
      const chars = Array.from(str);
      const out = [];
      for (let i = 0; i < chars.length; i += maxChars) {
        out.push(chars.slice(i, i + maxChars).join(''));
      }
      return out;
    }

    // ---------- (5) CDATA対策：]]> を安全に分割 ----------
    function cdataSafe(text) {
      // CDATA内に "]]>" が出たら XMLが壊れるので分割する
      // <![CDATA[aaa]]]]><![CDATA[>bbb]]> の形にする
      return (text || "").replace(/]]>/g, ']]]]><![CDATA[>');
    }

    async function handleFileSelect(evt) {
      const file = evt.target.files[0];
      if (!file) return;

      const selectedColor = document.getElementById('fontColorSelect').value;
      const encodingMode = document.getElementById('encodingSelect').value;

      const options = {
        mergeShortPages: document.getElementById('chkMergeShortPages').checked,
        replaceEnvChars: document.getElementById('chkReplaceEnvChars').checked,
        removePunctuation: document.getElementById('chkRemovePunctuation').checked,
        toFullWidth: document.getElementById('chkToFullWidth').checked,
        hyphenToChoonpu: document.getElementById('chkHyphenToChoonpu').checked,
        filterRules: filterRules
      };

      try {
        const { text: rawText, usedEncoding } = await readFileWithEncoding(file, encodingMode);
        const srtContent = normalizeNewlines(rawText);

        const gcmlContent = convertSrtToGcml(srtContent, selectedColor, options);
        const outputFilename = file.name.replace(/\.srt$/i, '') + '.gcml';

        downloadFile(gcmlContent, outputFilename, 'application/xml');

        document.getElementById('status').innerText =
          `変換完了: ${outputFilename} がダウンロードされました。(SRT: ${usedEncoding}, フィルター ${options.filterRules.length} 件適用)`;
      } catch (err) {
        document.getElementById('status').innerText = `エラー: ${err.message}`;
      }
    }

    function downloadFile(content, fileName, contentType) {
      const a = document.createElement('a');
      const file = new Blob([content], { type: contentType });
      a.href = URL.createObjectURL(file);
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function convertSrtToGcml(srt, fontColor, options) {
      let captions = [];

      // ブロック分割（空行区切り）
      const blocks = normalizeNewlines(srt).split(/\n\s*\n/);

      // タイムコード行の検出
      const srtTimeFormat = /(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/;

      for (const block of blocks) {
        if (block.trim() === "") continue;

        const lines = normalizeNewlines(block)
          .split('\n')
          .map(l => l.trimEnd());

        // ブロック内からタイムコード行を探す
        const timeIdx = lines.findIndex(l => srtTimeFormat.test(l));
        if (timeIdx === -1) continue;

        const timeLine = lines[timeIdx].match(srtTimeFormat);
        if (!timeLine) continue;

        const startTime = `${timeLine[1]}:${timeLine[2]}:${timeLine[3]}.${timeLine[4]}`;
        const startTimeMs = parseTimeToMs(timeLine[1], timeLine[2], timeLine[3], timeLine[4]);
        const endTimeMs = parseTimeToMs(timeLine[5], timeLine[6], timeLine[7], timeLine[8]);
        const durationMs = endTimeMs - startTimeMs;

        const textLines = lines
          .slice(timeIdx + 1)
          .map(l => {
            let processedLine = l.replace(/[\r\n]+$/, '');

            // フィルター（任意）
            if (options.filterRules && options.filterRules.length > 0) {
              for (const rule of options.filterRules) {
                const findRegExp = new RegExp(escapeRegExp(rule.find), 'g');
                processedLine = processedLine.replace(findRegExp, rule.replace);
              }
            }

            // 環境依存文字
            if (options.replaceEnvChars) {
              processedLine = processedLine.replace(
                /[\u2460-\u2473\u32D0-\u32FE\u2160-\u217F\u3300-\u3357\u3231\u3232\u2121\u2116]/g,
                '＊'
              );
            }

            // 半角→全角
            if (options.toFullWidth) {
              processedLine = toFullWidth(processedLine);
            }

            // 句読点削除
            if (options.removePunctuation) {
              processedLine = processedLine.replace(/[、。,.，．]/g, '');
            }

            // ハイフン→長音符
            if (options.hyphenToChoonpu) {
              processedLine = processedLine.replace(/-/g, 'ー');
            }

            return processedLine;
          })
          .filter(l => l !== "");

        captions.push({ startTime, startTimeMs, textLines, durationMs });
      }

      // 結合処理
      let finalCaptions = captions;

      if (options.mergeShortPages) {
        let workCaptions = JSON.parse(JSON.stringify(captions));
        const mergeThresholdMs = 1667; // 1秒20F相当
        const maxGapMs = 3000;         // 結合を許可する最大間隔（3秒）

        let i = 0;
        while (i < workCaptions.length) {
          const current = workCaptions[i];

          if (current.durationMs <= mergeThresholdMs && workCaptions.length > 1) {
            const prevIdx = i - 1;
            const nextIdx = i + 1;

            const prev = (prevIdx >= 0) ? workCaptions[prevIdx] : null;
            const next = (nextIdx < workCaptions.length) ? workCaptions[nextIdx] : null;

            let gapToPrev = Infinity;
            let gapToNext = Infinity;

            if (prev) {
              gapToPrev = current.startTimeMs - (prev.startTimeMs + prev.durationMs);
            }
            if (next) {
              gapToNext = next.startTimeMs - (current.startTimeMs + current.durationMs);
            }

            const canMergePrev = (prev && gapToPrev <= maxGapMs);
            const canMergeNext = (next && gapToNext <= maxGapMs);

            let mergeTarget = null;

            if (canMergePrev && !canMergeNext) {
              mergeTarget = 'prev';
            } else if (!canMergePrev && canMergeNext) {
              mergeTarget = 'next';
            } else if (canMergePrev && canMergeNext) {
              // 両方OKなら「gapが小さい方」を優先。同じなら、短い方に寄せる
              if (gapToPrev < gapToNext) {
                mergeTarget = 'prev';
              } else if (gapToNext < gapToPrev) {
                mergeTarget = 'next';
              } else {
                mergeTarget = (prev.durationMs <= next.durationMs) ? 'prev' : 'next';
              }
            }

            if (mergeTarget === 'prev') {
              // 前に結合
              workCaptions[prevIdx].durationMs =
                (current.startTimeMs + current.durationMs) - workCaptions[prevIdx].startTimeMs;
              workCaptions[prevIdx].textLines =
                workCaptions[prevIdx].textLines.concat(current.textLines);
              workCaptions.splice(i, 1);
              continue;
            }

            if (mergeTarget === 'next') {
              // 後ろに結合（next を current の開始に寄せる）
              const newDuration =
                (workCaptions[nextIdx].startTimeMs + workCaptions[nextIdx].durationMs) - current.startTimeMs;

              workCaptions[nextIdx].startTime = current.startTime;
              workCaptions[nextIdx].startTimeMs = current.startTimeMs;
              workCaptions[nextIdx].durationMs = newDuration;
              workCaptions[nextIdx].textLines =
                current.textLines.concat(workCaptions[nextIdx].textLines);

              workCaptions.splice(i, 1);
              continue;
            }

            i++;
          } else {
            i++;
          }
        }

        finalCaptions = workCaptions;
      }

      // 出力（作成日時）
      const now = new Date();
      const createDate = `${now.getFullYear()}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getDate().toString().padStart(2, '0')}`;
      const createTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

      let gcml = `<?xml version="1.0" encoding="UTF-8"?>
<gcml version="1.0">
  <head>
    <style type="text/css" left="180" top="30" width="620" height="480" font-size="36" font-hsp="4" font-vsp="24" font-color="${fontColor}"/>
    <meta>
      <event_info broadcast_name="BSY" event_code="YOUR_EVENT_CODE" event_title="YOUR_TITLE" event_sub_title="" language_code="jpn" media_flag=" * " video_flag="* " expiration_date="" creator_name="YOUR_NAME" create_date="${createDate}" create_time="${createTime}" onair_date_start="" onair_date_end="" onair_time="" onair_duration=""/>
    </meta>
  </head>
  <body style="left:180;top:30;width:620;height:480;font-size:36;font-hsp:4;font-vsp:24;font-color:${fontColor};" resolution="960x540" display_aspect_ratio="16v9" caption_max_bitrate="256000" caption_management_data_interval="1000" caption_background_type="TRANSPARENT" start_offset_time="0" duration="">
`;

      finalCaptions.forEach((cap, i) => {
        const pageNum = i + 1;
        const divStyle = 'style="left:180;top:30;width:620;height:480;font-size:36;font-hsp:4;font-vsp:24;" caption_background_type="SEMITRANSPARENT" caption_background_color="black"';

        gcml += `    <div page="${pageNum}" start_time="${cap.startTime}" ${divStyle}>\n`;

        const maxChars = 15;
        const processedLines = [];

        cap.textLines.forEach(originalLine => {
          const charLen = Array.from(originalLine).length;
          if (charLen <= maxChars) {
            processedLines.push(originalLine);
          } else {
            processedLines.push(...splitByChars(originalLine, maxChars));
          }
        });

        const lineHeight = 60;
        const startY = 330;

        processedLines.forEach((line, j) => {
          const topPos = startY + (j * lineHeight);
          const safe = cdataSafe(line); // ← CDATA安全化
          const pStyle = `style="left:180;top:${topPos};font-size:36;font-color:${fontColor};" caption_background_type="SEMITRANSPARENT" caption_background_color="black" language="jpn"`;
          gcml += `      <p ${pStyle}><![CDATA[${safe}]]></p>\n`;
        });

        gcml += '    </div>\n';
      });

      gcml += '  </body>\n</gcml>\n';
      return gcml;
    }
  </script>
</body>
</html>
